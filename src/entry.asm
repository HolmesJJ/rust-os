# -------------------------------------------------------------------------
# 这一部分是代码段，告诉编译器这部分指令需要放在程序的“入口”位置
# -------------------------------------------------------------------------
    .section .text.entry
    .globl _start

# _start 是硬件/固件约定的起始符号，类似于 C/Rust 里的 main
_start:
    # 1. 设置栈指针（Stack Pointer）
    # la = Load Address (加载地址)
    # 将 boot_stack_top 这个标签所在的内存地址存入 sp 寄存器
    # 在 RISC-V 中，sp 寄存器专门用来指向当前的栈顶
    # 当进入 Rust 代码后，一旦调用函数、定义局部变量，Rust 就会尝试向 sp 指向的地址写入数据。
    # 如果这时 sp 是空的（或者是指向了错误的地址），程序会立刻崩溃。
    la sp, boot_stack_top

    # 2. 跳转到 Rust 编写的主函数
    # call 指令会跳到 rust_main，并在完成后尝试返回（虽然内核通常不返回）
    call rust_main

# -------------------------------------------------------------------------
# 这一部分是数据段，专门用来在内存中预留一块空间给“栈”使用
# -------------------------------------------------------------------------
    .section .bss.stack
    .global boot_stack

# 在 RISC-V 架构中，栈是从高地址向低地址增长的。
# 栈的起始位置（低地址）
boot_stack:
    # .space 表示开辟一段连续的空内存
    # 4096 * 16 = 65536 字节，即 64KB 的启动栈空间
    .space 4096 * 16
    .global boot_stack_top
# 栈的顶部（末尾）位置（高地址）
boot_stack_top:
    # 这里的标签紧跟在 .space 之后，所以它的地址就是这段空间的末尾
    # 注意：RISC-V 的栈是向低地址增长的，所以 sp 要指向最高处
    # 当 Rust 往栈里压入数据时，地址会变小，正好落在这 64KB 的预留范围内。
